# HTML（5）

# HTML/CSS 基础知识

罗列一些基础内容。

## 资料

学习资料可以参考[HTML Dog](http://www.htmldog.com/guides/html/)以及[Learn HTML & CSS](http://learn.shayhowe.com/html-css/)。

详细的文档内容，推荐参考[WebPlatform](http://docs.webplatform.org/wiki/Main_Page)和[MDN](https://developer.mozilla.org/en-US/docs/Web)。

关于属性的兼容性，可以通过[Can I Use](http://caniuse.com/)查询。

## 1.概念

HTML全程”Hyper Text Markup Language“，即超文本标记语言，用来描述网页。

## 2.基本结构

![image-20210720095444786](C:\Users\kEEpkind-\AppData\Roaming\Typora\typora-user-images\image-20210720095444786.png)



## 3.HTML常用标签

### div(块级元素)

div标签用于组合其他HTML元素，本身无实在意义。常用于页面的布局，比如一个展开式的广告页面框架大致如下：

```
<body>
    <div id="wrap-container">
        <div id="collapsed-container"></div>
        <div id="expanded-container"></div>
    </div>
</body>
```

## h1~h6(块级元素), p(块级元素), span(行内元素), strong, em...

此类标签用于设置文本，常见的使用方式是填充段落，比如弹出的legal框文字HTML结构如下:

```
<div id="legal-window">
    <h4>LEGAL</h4>
    <img id="legal-close" src="img/embed/legal-close.png" alt="close window">
    <p>*Requires a system with Intel<sup>&reg;</sup> Turbo Boost Technology. Intel<sup>&reg;</sup> Turbo Boost Technology and Intel<sup>&reg;</sup> Turbo Boost Technology 2.0 are only available on select Intel<sup>&reg;</sup> processors. Consult your PC manufacturer. Performance varies depending on hardware, software, and system configuration. For more information, visit http://www.intel.com/go/turbo. Copyright &copy; 2014 Intel Corporation. All rights reserved. Intel, the Intel logo, Intel Core, Look Inside, Intel Inside, and Pentium are trademarks of Intel Corporation in the U.S. and/or other countries. Other names and brands may be claimed as the property of others.</p>
</div>
```

## ul(无序), li, ol(有序), dl, dt, dd

此类标签用于设置带有列表内容的，比如导航栏的下拉菜单，多视频的缩略图等：

```
<ul class="nav-tools-list">
    <li>
        <div>
            <img src="shoppingtools-icon-1.png" alt="">
            <span>Build & Price</span>
        </div>
    </li>
    <li>
        <div>
            <img src="shoppingtools-icon-2.png" alt="">
            <span>Incentives & Offers</span>
        </div>
    </li>
    <li>
        <div>
            <img src="shoppingtools-icon-3.png" alt="">
            <span>Request a Local Quote</span>
        </div>
    </li>
    <li>
        <div>
            <img src="shoppingtools-icon-4.png" alt="">
            <span>Search Dealer Inventory</span>
        </div>
    </li>
</ul>
```

## form(块级元素)表单相关

页面中涉及到表单时候，需要使用到form相关标签：

```
<form name="frm-sample" class="frm-sample" action="try" method="post">
    <input type="text" class="form-control" placeholder="Name">
    <div id="status-message"></div>
    <div id="sample-captcha"></div>
    <a id="check-is-filled" class="info-btn">Check if visualCaptcha is filled</a>
    <button type="submit" name="submit-bt" class="submit">Submit form</button>
</form>
```

## table表格相关

页面中涉及到table结构，需要使用到table相关标签:

```
<talbe></talbe>
```

## img, canvas

用于图像显示。一般不直接操作img,canvas元素，而是在它的外层包裹一层父级元素（可以为span,div等)，对父级元素进行操作：

```
<div class="preload" data-src="CheddarBacon.png">
    <img src="CheddarBacon.png" alt="">
</div>
<!-- or -->
<div id="sprite-car" class="cw-sprite sprite-car" cw-interval="30" cw-loops="1" cw-auto-play="false" cw-texture="images/sprites/expanded/car-texture.png" cw-mapper="car">
    <canvas class="cw-renderer" width="460" height="130"></canvas>
</div>
```

## a

a标签用于打开链接，发送邮件，段落跳转等功能。使用时需要注意阻止掉标签的默认事件。

链接跳转，常见的关于分享按钮的HTML结构如下：

```
<div id="shareBox">
    <ul>
        <li id="facebook">
            <a target="_blank" rel="nofollow" data-shareWay="facebook">
                <img alt="Post on Facebook" src="img/embed/f4Icon3.png" alt="Facebook" />
            </a>
        </li>
        <li id="twitter">
            <a target="_blank" rel="nofollow" data-shareWay="twitter">
                <img alt="Tweet this" src="img/embed/f4Icon4.png" />
            </a>
        </li>
        <li id="pinterest">
            <a data-pin-do="buttonPin" data-pin-config="none" target="_blank" rel="nofollow" data-shareWay="pinterest">
                <img alt="Pin it" src="img/embed/f4Icon5.png" />
            </a>
        </li>
        <li id="email">
            <a target="_blank" rel="nofollow" data-shareWay="email">
                <img src="img/embed/f4Icon6.png" />
            </a>
        </li>
    </ul>
    <p></p>
</div>
```

发送邮件的代码片段如下：

```
<div class="button">
  <a class="mail" data-img="mail.png" href="mailto:[email protected]?subject=xxx&body=xxx"></a>
</div>
```

段落跳转代码片段如下：

```
<div id="html5"></div>
<a name="user-content-html5" href="#html5" class="headeranchor-link" aria-hidden="true"><span class="heade
```

## button

该标签定义了一个案件，可以用**onclick="alert('点我干啥!');"**实现弹窗；**onclick** 事件会在元素被点击时发生。

# HTML语义化

语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

## 参考资料

- [semantic-html](http://justineo.github.io/slideshows/semantic-html/)
- [关于语义化 HTML 以及前端架构的一点思考](http://www.oschina.net/translate/about-html-semantics-front-end-architecture)
- [如何理解 web 语义化](http://www.zhihu.com/question/20455165)



## DOCTYPE和浏览器渲染模式

文档类型，一个文档类型标记是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。Doctype还会对浏览器的渲染模式产生影响，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析，所以Doctype是非常关键的，尤其是在 IE 系列浏览器中，由DOCTYPE 所决定的 HTML 页面的渲染模式至关重要。

### 浏览器解析HTML方式

有三种解析方式:

- 非怪异（标准）模式
- 怪异模式
- 部分怪异（近乎标准）模式

在“标准模式”(standards mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式(quirks mode) 模式”中则尝试模拟更旧的浏览器的行为。 一些浏览器（例如，那些基于 Mozilla 的 Gecko 渲染引擎的，或者 Internet Explorer 8 在 strict mode 下）也使用一种尝试于这两者之间妥协的“近乎标准”(almost standards) 模式，实施了一种表单元格尺寸的怪异行为，除此之外符合标准定义。

一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。

HTML5提供的`<DOCTYPE html>`是标准模式，向后兼容的, 等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。

## 参考资料

- [DOCTYPE和浏览器渲染模式](https://github.com/iamjoel/front-end-note/blob/master/detail/html/quirks-mode-and-standards-mode.md)
- [CS002: DOCTYPE 与浏览器模式分析](http://w3help.org/zh-cn/casestudies/002)
- [怪异模式（Quirks Mode）对 HTML 页面的影响](http://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/)



## 理解DOM结构

DOM: Document Object Module, 文档对象模型。我们通过JavaScript操作页面的元素，进行添加、移动、改变或移除的方法和属性, 都是DOM提供的。

### W3C DOM 标准

被分为 3 个不同的部分:

- 核心 DOM - 针对任何结构化文档的标准模型
- XML DOM - 针对 XML 文档的标准模型
- HTML DOM - 针对 HTML 文档的标准模型

### DOM节点

根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：

- 整个文档是一个文档节点
- 每个 HTML 元素是元素节点
- HTML 元素内的文本是文本节点
- 每个 HTML 属性是属性节点
- 注释是注释节点

### HTML DOM 节点树

HTML文本会被解析为DOM树, 树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。

![ct_htmltree](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/ct_htmltree.gif)

### 节点的关系

父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）:

- 在节点树中，顶端节点被称为根（root）
- 每个节点都有父节点、除了根（它没有父节点）
- 一个节点可拥有任意数量的子
- 同胞是拥有相同父节点的节点

![dom_navigate](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/dom_navigate.gif)

## 参考资料

- [W3C: Document Object Model (DOM) Technical Reports](http://www.w3.org/DOM/DOMTR)
- [MDN: DOM API](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)
- [浏览器的工作原理：新式网络浏览器幕后揭秘](http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [开发者需要了解的WebKit](http://www.infoq.com/cn/articles/webkit-for-developers)
- [理解WebKit和Chromium: HTML解析和DOM](http://blog.csdn.net/milado_nju/article/details/7886253)
- [HTML解析原理](http://www.cnblogs.com/NetSos/archive/2010/11/29/1891194.html)



## HTML5新增内容

HTML5 是对 HTML 标准的第五次修订。其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。HTML5 的语法是向后兼容的。现在国内普遍说的 H5 是包括了 CSS3，JavaScript 的说法（严格意义上说，这么叫并不合适，但是已经这么叫开了，就将错就错了）。

### 与HTML 4的不同之处

- 文件类型声明（<!DOCTYPE>）仅有一型：<!DOCTYPE HTML>。
- 新的解析顺序：不再基于SGML。
- 新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。
- input元素的新类型：date, email, url等等。
- 新的属性：ping（用于a与area）, charset（用于meta）, async（用于script）。
- 全域属性：id, tabindex, repeat。
- 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。
- 移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt。

### 新增标签

HTML 5提供了一些新的元素和属性，反映典型的现代用法网站。其中有些是技术上类似`<div>`和`<span>`标签，但有一定含义，例如`<nav>`（网站导航块）和`<footer>``<audio>`和`<video>`标记。

### 移除的标签

一些过时的HTML 4标记将取消，其中包括纯粹用作显示效果的标记，如`<font>`和`<center>`，因为它们已经被CSS取代。还有一些通过DOM的网络行为。

### 修改的标签

尽管和SGML在标记上的相似性，HTML5的句法并不再基于它了，而是被设计成向后兼容对老版本的HTML的解析。它有一个新的开始列看起来就像SGML的文档类型声明，`<!DOCTYPE HTML>`，这会触发和标准兼容的渲染模式。在2009年1月5号，HTML5添加了Web Form 2.0的内容，html5开始发展起来。

### 无障碍（Accessibility）

为了使HTML5的新元素或新属性获取最大化的兼容性，开发人员需要附加一点额外补助，或者有些特性根本没有被任何浏览器实现，或者浏览器根本不支持补助技术。因此有些特殊的HTML5特性根本不能使用。更多细节可参见HTML5 Accessibility（无障碍）

### 新应用程序接口（API）

除了原先的DOM接口，HTML5增加了更多样化的API:

- HTML Geolocation
- HTML Drag and Drop
- HTML Local Storage
- HTML Application Cache
- HTML Web Workers
- HTML SSE
- HTML Canvas/WebGL
- HTML Audio/Video

## 参考资料

- [维基百科: html5](http://zh.wikipedia.org/wiki/HTML5)
- [MDN: HTML5](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5)
- [W3Schools: Learn HTML5](http://www.w3schools.com/html/html5_intro.asp)
- [知乎: HTML5 到底是什么？](http://www.zhihu.com/question/19812140)





# CSS（3）

## 盒模型

盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。需要记住的是："every element in web design is a rectangular box"。如图：

![box-model](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/box-model.svg)

CSS3中新增了一种盒模型计算方式：`box-sizing`熟悉。盒模型默认的值是`content-box`, 新增的值是`padding-box`和`border-box`，几种盒模型计算元素宽高的区别如下：

### content-box（默认）

布局所占宽度Width：

```
Width = width + padding-left + padding-right + border-left + border-right
```

布局所占高度Height:

```
Height = height + padding-top + padding-bottom + border-top + border-bottom
```

### padding-box

布局所占宽度Width：

```
Width = width(包含padding-left + padding-right) + border-top + border-bottom
```

布局所占高度Height:

```
Height = height(包含padding-top + padding-bottom) + border-top + border-bottom
```

### border-box

布局所占宽度Width：

```
Width = width(包含padding-left + padding-right + border-left + border-right)
```

布局所占高度Height:

```
Height = height(包含padding-top + padding-bottom + border-top + border-bottom)
```

### margin叠加

外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。

一般来说， 垂直外边距叠加有三种情况：

- 元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。
- 相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。
- 包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。

## CSS普通流（文档流）

首先明确一点的是，W3C规范中没有`document flow`这个概念，只有[normal-flow](http://www.w3.org/TR/CSS2/visuren.html#normal-flow), 文档流的叫法主要还是多数中文译者的翻译方式问题。

### 定义

什么是普通流？简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述。

### 调节普通流元素位置

一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。

只要不是**float**和**绝对定位**方式布局的，都在普通流里面。

## CSS定位方式

### display属性

每一个元素都有默认的display属性，使用最多的是`block`, `inline`和`inline-block`，不常用的是`table-cell`。

根据display属性，我们可以将元素分为块级元素(block)和内联级元素(inline)。它们最大区别是:`block`元素可以设置宽度，独占一行。`inline`元素宽度由内容决定，与其他元素并列在一行。

**常见的block属性元素**有：`div, h1-h6, ul, li, ol, dl, dd, dt`。

**常见的inline属性元素**有: `span, a, em`。

### block

宽高可以自行设置，默认宽度由父容器决定，默认高度有内容决定。自己独占一行。

### inline

宽度和高度都有内容决定，与其他元素共占一行。

### inline-block

宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中。

### table-cell

此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。

### position属性

元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为`static`。它其实是未被设置定位的。

元素如果被定位了，那么它的`top,left,bottom,right`值就会生效，能设置定位的属性是`relative`,`absolute`和`fixed`。

需要注意的另一点是被定位的元素层次(`z-index`)会得到提高。

### relative（相对定位）

```
相对于原来位置的偏移，可能会覆盖其他元素。
left top right bottom属性
```



设置了相对定位之后，通过修改`top,left,bottom,right`值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。

### absolute（绝对定位）

```
以body元素的左上角为原点进行相对定位，以所有自己的父元素中离自己最近的除了static定位以外的父元素的左上角为原点，脱离文档流。
```



设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于是它最近的设置了定位属性（`position`值不为static）的元素。

且如果元素为块级元素（`display`属性值为`block`)，那么它的宽度也会由内容撑开。因为：

> 默认文档流中块级元素如果没有设置宽度属性，会自动填满整行。

### fixed(固定定位)

```
相对于屏幕视窗的位置定位，元素的位置不会随着屏幕滚动发生变化。
```



设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置。

## CSS浮动相关

这也是CSS定位机制的一种。

```
float:left //让元素向左浮动
float:right //让元素向右浮动
inherit //让元素从父级继承浮动属性，脱离文本流
注意：宽度不能写百分比，%会随着可视窗口大小变化。
```



首先了解两个概念：

1. 文档流：文档流是文档中可显示对象在排列时所占用的位置。
2. 浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。

浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似Inline-block)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的`overflow`属性为`auto`,使其自动撑满。

### 清除浮动

[那些年我们一起清除过的浮动](http://www.iyunlu.com/view/css-xhtml/55.html)

## CSS选择器

选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如`document.document.querySelectorAll`。

### 关于CSS解析器

HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。

Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。

在建立 Render Tree 时（WebKit 中的「Attachment」过程），**浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的**，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。

### 解析顺序

CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。

### 选择器权重

权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。

根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） > style标签 > link标签。

另外一点需要注意的是`!improtant`,凡是属性值后加上了`!important`，那么它的值不会被其他值替换。

### 权重的计算

通过这篇文章[你应该知道的一些事情——CSS权重](http://www.w3cplus.com/css/css-specificity-things-you-should-know.html)。了解下权重的计算，主要的规则就是:

```
id选择器 > 类，属性选择器和伪类选择器 > 元素和伪元素
```

### 基本选择器

- 通配符选择器（`＊`）

- id选择器（`\#ID`）

- 类选择器（`.className`）

- 元素选择器(`E`)

- 后代选择器（`Ｅ Ｆ`）

- 子元素选择器(`E>F`)

- 相邻兄弟元素选择器(`E + F`)

- 群组选择器（`selector1,selector2,...,selectorN`）

  ![image-20210720110813369](C:\Users\kEEpkind-\AppData\Roaming\Typora\typora-user-images\image-20210720110813369.png)

### 属性选择器

使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。

- `E[attr]`：只使用属性名，但没有确定任何属性值
- `E[attr="value"]`：指定属性名，并指定了该属性的属性值
- `E[attr~="value"]`：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写
- `E[attr^="value"]`：指定了属性名，并且有属性值，属性值是以value开头的；
- `E[attr$="value"]`：指定了属性名，并且有属性值，而且属性值是以value结束的；
- `E[attr*="value"]`：指定了属性名，并且有属性值，而且属值中包含了value；
- `E[attr|="value"]`：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）;

### 伪类选择器

伪类选择器的形式就是`:xxx`， 比如`:hover, :link, :nth`。

### 动态伪类

这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来，动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如":link",":visited";另外一种被称作用户行为伪类，如“:hover”,":active"和":focus"。先来看最常见的锚点伪类。

- hover: 用于当用户把鼠标移动到元素上面时的效果
- active: 用于用户点击元素那一下的效果（正发生在点的那一下，松开鼠标左键此动作也就完成了）
- focus: 用于元素成为焦点，这个经常用在表单元素上

### UI元素状态伪类

主要是针对于HTML中的Form元素操作, IE8不支持":checked",":enabled",":disabled"这三种选择器。

### CSS3的:nth选择器

主要注意的是CSS3添加的nth选择器在IE8下不支持。

- fist-child: 选择某个元素的第一个子元素；
- last-child: 选择某个元素的最后一个子元素；
- nth-child(): 选择某个元素的一个或多个特定的子元素；
- 其他： 常用的就是上面三种了，其他自行了解。

### 选择器分类总结

见图:

![css-selector](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/css-selector.jpg)

### 选择器兼容性

选择器的兼容性:

![css选择器兼容性](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7.jpg)

### 选择器的优化

- [CSS选择器的优化](http://www.w3cplus.com/css/css-selector-performance)

### 参考资料

- [一个CSS选择器游戏](http://flukeout.github.io/)
- [CSS选择器支持情况](http://labs.qianduan.net/css-selector/)
- [CSS选择器文档](http://www.w3.org/TR/css3-selectors/)
- [CSS3 选择器——基本选择器](http://www.w3cplus.com/css3/basic-selectors)
- [CSS3 选择器——属性选择器](http://www.w3cplus.com/css3/attribute-selectors)
- [CSS3 选择器——伪类选择器](http://www.w3cplus.com/css3/pseudo-class-selector)
- [CSS SELECTORS AND PSEUDO SELECTORS BROWSER COMPATIBILITY](http://kimblim.dk/css-tests/selectors/)
- [Browser CSS-Selector-Test](http://css4-selectors.com/browser-selector-test/)



## CSS常见布局

### 'display', 'position', and 'float'三者对布局的影响

> The three properties that affect box generation and layout — 'display', 'position', and 'float' — interact as follows: If 'display' has the value 'none', then 'position' and 'float' do not apply. In this case, the element generates no box. Otherwise, if 'position' has the value 'absolute' or 'fixed', the box is absolutely positioned, the computed value of 'float' is 'none', and display is set according to the table below. The position of the box will be determined by the 'top', 'right', 'bottom' and 'left' properties and the box's containing block. Otherwise, if 'float' has a value other than 'none', the box is floated and 'display' is set according to the table below. Otherwise, if the element is the root element, 'display' is set according to the table below, except that it is undefined in CSS 2.1 whether a specified value of 'list-item' becomes a computed value of 'block' or 'list-item'. Otherwise, the remaining 'display' property values apply as specified.

一张图: ![Visual-formatting-model](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/Visual-formatting-model.jpg)

### 常见布局

### 固定尺寸

布局可以从固定尺寸先了解，先构思好页面的主要结构，做动画的元素一般需要绝对定位，方便操作移动。

### 自适应布局

响应式的布局的结构其实就是多个固定尺寸的组合，元素的宽度，字体的大小一般会以半分比的形式设置。通过媒体查询进行不同分辨率下的布局。

### 布局方式

### 居中设置

关于居中，要学会设置水平居中和垂直居中。参考文章:[如何只用CSS做到完全居中](http://blog.jobbole.com/46574/)。

## 参考资料

- [学习CSS布局](http://zh.learnlayout.com/)
- [CSS 布局:40个教程、技巧、例子和最佳实践](http://coolshell.cn/articles/6840.html)
- [详解css3弹性盒模型（Flexbox）](http://segmentfault.com/a/1190000000707526)
- [CSS Grid布局：什么是网格布局](http://segmentfault.com/a/1190000002437544)
- [W3c: Relationships between 'display', 'position', and 'float'](http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo)



## CSS书写与命名

开发过程最耗时的是什么？其实是命名。。。

每个团队都应该拥有一套开发规范，其中应该也包含了命名规范。对于CSS而言，命名的组织方式又有多种，下面我们一起看看。

### 遵守的原则

首先是命名要讲究简单而不失语义化，其次要时刻思考复用性，选择器的性能等。

### 语义化命名

这是较为传统的方式，就是div是干什么的，就起什么名字。这种方式好处是清晰明了，但是缺点是和HTML元素高度耦合。不利于大型项目的复用，比如起名都是按照组件的位置而定的情况。

### 书写顺序

1. 位置属性(position, top, right, z-index, display, float等)
2. 大小(width, height, padding, margin)
3. 文字系列(font, line-height, letter-spacing, color- text-align等)
4. 背景(background, border等)
5. 其他(animation, transition等)



## CSS3新增特性

### 选择器

具体的支持情况，请查看:[CSS选择器的浏览器支持](http://labs.qianduan.net/css-selector/).

### @Font-face 特性

加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。

### Word-wrap & Text-overflow 样式

### Word-wrap

设置`word-wrap: break-word`的话，在单词换行的情况下，可保持单词的完整性。

### Text-overflow

它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示, 我们在父容器设置`overflow: hidden`, 然后设置“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。"clip"表示直接切割，"ellipsis"表示用省略号代替。

### 文字渲染（Text-decoration）

- Text-fill-color: 文字内部填充颜色
- Text-stroke-color: 文字边界填充颜色
- Text-stroke-width: 文字边界宽度

### CSS3 的多列布局（multi-column layout）

- Column-count：表示布局几列。
- Column-rule：表示列与列之间的间隔条的样式
- Column-gap：表示列于列之间的间隔

### 边框和颜色（color, border）

支持`rgba`和`hsl`表示颜色, 支持圆角，阴影等效果。

### CSS3 的渐变效果（Gradient）

支持线性渐变和径向渐变。

### CSS3 的阴影（Shadow）和反射（Reflect）效果

阴影效果，阴影效果既可用于普通元素，也可用于文字。

### CSS3 的背景效果

- “Background Clip”，该属确定背景画区
- “Background Origin”，用于确定背景的位置，它通常与 background-position 联合使用，您可以从 border、padding、content 来计算 background-position（就像 background-clip）。
- “Background Size”，常用来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身。
- “Background Break”属性，CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。
- 多背景图片支持

### CSS3 的盒子模型

```
display: -webkit-box; 
display: -moz-box; 
-webkit-box-orient: horizontal; 
-moz-box-orient: horizontal;
```

“display: -webkit-box; display: -moz-box;”，它针对 webkit 和 gecko 浏览器定义了该元素的盒子模型。注意这里的“-webkit-box-orient: horizontal;”，他表示水平排列的盒子模型。如果配合元素的`box-flex`属性：

```
.flex { 
     -webkit-box-flex: 1; 
     -moz-box-flex: 1; 
 } 

 .flex2 { 
     -webkit-box-flex: 2; 
     -moz-box-flex: 2; 
 }
```

水平方向设下的宽度，就可以按照1:2的比例关系自动去计算了。

### CSS3 的 Transitions, Transforms 和 Animation

### Transitions

- transition-property：用于指定过渡的性质，比如 transition-property:backgrond 就是指 backgound 参与这个过渡
- transition-duration：用于指定这个过渡的持续时间
- transition-delay：用于制定延迟过渡的时间
- transition-timing-function：用于指定过渡类型，有 ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier

### Transforms

指拉伸，压缩，旋转，偏移等等一些图形学里面的基本变换。

### Animation

```
@-webkit-keyframes anim1 { 
    0% { 
        Opacity: 0; 
 Font-size: 12px; 
    } 
    100% { 
        Opacity: 1; 
 Font-size: 24px; 
    } 
 } 
 .anim1Div { 
    -webkit-animation-name: anim1 ; 
    -webkit-animation-duration: 1.5s; 
    -webkit-animation-iteration-count: 4; 
    -webkit-animation-direction: alternate; 
    -webkit-animation-timing-function: ease-in-out; 
 }
```

## 总结

CSS的详细属性，可以查阅: [css3-cheat-sheet.pdf](https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/assets/css3-cheat-sheet.pdf)



## 常用meta整理

### 概要

标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。

### 基本属性

| 属性       | 值                                                           | 描述                                   |
| :--------- | :----------------------------------------------------------- | :------------------------------------- |
| keywords   | author / description / keywords / generator / revised / others | 把 content 属性关联到一个名称。        |
| content    | some text                                                    | 定义与http-equiv或name属性相关的元信息 |
| http-equiv | content-type / expire / refresh / set-cookie                 | 把content属性关联到HTTP头部。          |

### 参考资料

- [常用meta整理](http://segmentfault.com/blog/ciaocc/1190000002407912)

### 参考资料

- [深入了解CSS3新特性](https://www.google.com.sg/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CBwQFjAA&url=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2F1202_zhouxiang_css3%2F&ei=KcggVYq1Nc6zuASIpoLgBw&usg=AFQjCNHFv9vuBe1P1PfA_fUjs50ovzxw4w&sig2=eiKrEBjQGWBwU5AN18hMiA&bvm=bv.89947451,d.c2E&cad=rjt)
- [Introduction to CSS3](http://designshack.net/tutorials/introduction-to-css3-part-1-what-is-it)
- [css3 info](http://www.css3.info/)
- [CSS3 Cheat Sheet (PDF)](http://www.smashingmagazine.com/2009/07/13/css-3-cheat-sheet-pdf/)



## 什么是Viewport

### 参考资料

- [什么是Viewport Meta（width详解）及在手机上的应用](http://ourjs.com/detail/54c73ba2232227083e00001a)



## HTML/CSS进阶

### 参考资料

- [一丝: CSS进阶之路](https://onedrive.live.com/view.aspx?cid=4817543FE4BCFC5E&resid=4817543FE4BCFC5E!108&app=PowerPoint)



# 自定义字体

css3的一个新特性就是可以支持自定义字体，使网页中显示用户本地不存在的字体。

## 字体格式

### EOT – Embedded Open Type (.eot)

嵌入字体格式（EOT）是微软开发的一种技术，允许 OpenType 字体嵌入到网页并可以下载至浏览器渲染，浏览器根据 CSS 中 @font-face 的定义，下载，渲染这种 .EOT 后缀的字体文件。这些文件只在当前页活动的状态下，临时安装在用户的系统中。

### WOFF – Web Open Font Format (.woff)

相对于 TrueType 和 OpenType ，WOFF（Web开发字体格式）是一种专门为了 Web 而设计的字体格式标准，它并不复杂，实际上只是对于 TrueType / OpenType 等字体格式的封装，并针对网络使用加以优化：每个字体文件中含有字体以及针对字体的元数据（Metadata），字体文件被压缩，以便于网络传输，并且不包含任何加密或者 DRM 措施。包括 Adobe、 Lino Type、Monotype 在内的几乎所有主要的字体供应商都加入到支持 WOFF 的行列中来

### SVG (Scalable Vector Graphics) Fonts (.svg)

顾名思义，就是使用SVG技术来呈现字体，还有一种gzip压缩格式的SVG字体.svgz。SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言（XML），用于描述二维矢量图形的一种图形格式。SVG由W3C制定，是一个开放标准。SVG严格遵从XML语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。SVG可以使你设计的网页可以更加精彩细致，使用简单的文本命令，SVG可实现色彩线性变化、路径、自定义字体、透明效果、滤镜效果等各式常见的图形图像效果。

### TrueType (.ttf)

Windows和Mac系统最常用的字体格式，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。

### OpenType (.otf)

OpenType是一种可缩放字型（scalable font）电脑字体类型，采用PostScript格式，是美国微软公司与Adobe公司联合开发，用来替代TrueType字型的新字型。这类字体的文件扩展名为.otf，类型代码是OTTO，现行标准为OpenType 1.4。OpenType最初发表于1996年，并在2000年之后出现大量字体。它源于微软公司的TrueType Open字型，TrueType Open字型又源于TrueType字型。OpenType font包括了Adobe CID-Keyed font技术。Adobe公司已经在2002年末将其字体库全部改用OpenType格式。

## 字体兼容性

- TureTpe(.ttf)格式: 【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】
- OpenType(.otf)格式：【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】
- Web Open Font Format(.woff)格式: 【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】
- Embedded Open Type(.eot)格式: IE专属格式，支持这种字体的浏览器有【IE4+】
- SVG(.svg)格式：【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】

在@font-face中我们至少需要.woff,.eot两种格式字体，甚至还需要.svg等字体达到更多种浏览版本的支持。

## @font-face的语法规则

```css
@font-face {
     font-family: <YourWebFontName>;
     src: <source> [<format>][,<source> [<format>]]*;
     [font-weight: <weight>];
     [font-style: <style>];
   }
```

取值说明:

1. YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:"YourWebFontName";”
2. source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；
3. format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；
4. weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。

为了使@font-face达到更多的浏览器支持，Paul Irish写了一个独特的@font-face语法叫Bulletproof @font-face:

```css
@font-face {
    font-family: 'YourWebFontName';
    src: url('YourWebFontName.eot?') format('eot');/*IE*/
    src:url('YourWebFontName.woff') format('woff'), url('YourWebFontName.ttf') format('truetype');/*non-IE*/
   }
```

但为了让各多的浏览器支持，你也可以写成：

```css
@font-face {
    font-family: 'YourWebFontName';
    src: url('YourWebFontName.eot'); /* IE9 Compat Modes */
    src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
             url('YourWebFontName.woff') format('woff'), /* Modern Browsers */
             url('YourWebFontName.ttf')  format('truetype'), /* Safari, Android, iOS */
             url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */
   }
```

## 参考资料

- [Airen的博客: CSS3 @font-face](http://www.w3cplus.com/content/css3-font-face)
- [Web字体格式介绍及浏览器兼容性一览](http://www.cnblogs.com/lhb25/archive/2011/02/10/1950473.html)
- [迟到的中文 WebFont](http://www.w3ctech.com/topic/669)
- [CSS3 icon font完全指南](http://www.qianduan.net/css3-icon-font-guide.html)
- [谈谈网页设计中的字体应用(3)：实战应用篇·上](http://web.jobbole.com/82275/)



## CSS基线

基线是排版上的一种名词，是指大部分字母所“坐落”其上的一条看不见的线，每条基线之间形成基本的基线网格。但是在web中，当我们需要垂直对齐的时候，基线往往让人失望，比如`line-height`属性。

### 参考资料

- [Wikipedia: baseline](http://en.wikipedia.org/wiki/Baseline_(typography))
- [CSS基线之道](http://www.qianduan.net/css-baseline-road.html)



## CSS动画

### 参考资料

- [利用 CSS animation 和 CSS sprite 制作动画](http://acwong.org/2015/03/23/make-animation-with-steps-and-css-sprite/)
- [css3动画总结](http://www.zhouwenbin.com/css3动画总结/)



# 前端UI框架

Web Component是未来的一种趋势，现阶段，还是很多CSS的基础框架，比如React。

## 参考资料

- [颠覆式前端UI开发框架：React](http://www.infoq.com/cn/articles/subversion-front-end-ui-development-framework-react)



# Bootstrap学习指南

附录里有一些相关的资料，这里就负责简述下这个前端框架，如何使用，以及制作一个简单的自适应页面。

## 介绍

Bootstrap是Twitter在2011年推出的一套前端框架组件，几大特点:

1. 快速开发, 组件和模块丰富
2. mobile first
3. 自适应
4. 兼容性好

## 使用

Bootstrap的代码可以到官方下载，我们也可以使用官方提供的CDN, 这里的例子我们就使用CDN吧。其他安装方式还可以选择:`bower`和`npm`。如果我们要自行构建代码的话，需要注意使用`Autoprefixer`插件，因为源码是`less`或`sass`编写的。使用官方的`gurntfile`构建的话，就不用管了。

## 基本结构

Bootstrap3是默认使用自适应的，如果要禁止自适应过程，请查阅:[Disabling responsiveness](http://getbootstrap.com/getting-started/#disable-responsive)

自适应的情况下，又提供了两种结构，adapt和responsive，通过给容器设置class决定:

- `container`: 分区间固定宽度
- `container-fluid`: 宽度100%

## Grid System

bootstrap可以将一行分为12列布局，这就形成了一个grid system。超过十二列的话，就会自动换到下一行了。表格系统使用的时候必须包含在`container`或`container-fluid`类中。并且是由`.row`直接包裹`.col-`。

### class分类

按照自适应的区间，划分了四类：

- Extra small devices Phones (<768px): xs
- Small devices Tablets (≥768px): sm
- Medium devices Desktops (≥992px): md
- Large devices Desktops (≥1200px): lg

### 设置偏移量

使用`.col-md-offset-*`来设置偏移。相当于在容器左侧添加了一个指定大小的`col`。

### col的嵌套

在`col`中还可以添加`.row`包裹`.col-`, 从而形成列的嵌套，宽度是按照父级的`col`计算的。

### 改变col的顺序

有时候我们在html中写的dom顺序，添加`.col-md-push-*` 和 `.col-md-pull-*`来改变float的`left`和`right`值。

## 排版文字相关

见: [Typography](http://getbootstrap.com/css/?#type)

## 代码相关

[Code](http://getbootstrap.com/css/?#code)

## 表格，表单，按钮

- [Tablets](http://getbootstrap.com/css/?#tables)
- [Forms](http://getbootstrap.com/css/?#forms)
- [Buttons](http://getbootstrap.com/css/?#buttons)

### 示例

[Bootstrap grid examples](http://getbootstrap.com/examples/grid/)

## 参考资料

- [w3schools: Bootstrap](http://www.w3schools.com/bootstrap/bootstrap_get_started.asp)
- [Bootstrap: Getting started](http://getbootstrap.com/getting-started/)
- [Bootstrap Expo](http://expo.getbootstrap.com/)

















# JavaScript

# JavaScript基础知识

描述一些容易混淆或者忘记的知识点。比如mouse事件的顺序，event属性有哪些。。。

## 参考资料

- [如何正确学习JavaScript？](http://web.jobbole.com/81758/)
- [JavaScript 标准参考教程（alpha）](http://javascript.ruanyifeng.com/):阮一峰写的教程。
- [JavaScript简易教程](http://yanhaijing.com/basejs/index.html)：最完整最简洁的JavaScript基础教程。



# 作用域问题

JavaScript语言的作用域仅存在于函数范围中。这是必须要牢记的一点，还有一点重要的就是作用域的提升规则。

## 作用域问题

JS最容易出现混淆的就是作用域的情况。传统的**类C语言**,它们的作用域是`block-level scope`，块级作用域， 花括号就是一个作用域。但是对于JavaScript而言，它的作用域是`function-level scope`，比如if条件语句，就不算一个独立的作用域:

```
var x = 1;
console.log(x); // 1
if (true) {
    var x = 2;
    console.log(x); // 2
}
console.log(x); // 2
```

在JavaScript中，如果我们需要实现`block-level scope`，我们也有一种变通的方式，那就是通过自执行函数创建临时作用域:

```
function foo() {
    var x = 1;
    if (x) {
        (function () {
            var x = 2;
            // some other code
        }());
    }
    // x is still 1.
}
```

## 作用域提升

### 变量被提升

对JavaScript解释器而言，所有的函数和变量声明都会被提升到最前面, 并且变量声明永远在前面，赋值在声明过程之后。比如:

```
var x = 10;
function x(){};
console.log(x); // 10
```

实际上被解释为:

```
var x;
function x(){};
x = 10;
console.log(x); // 10
```

## 函数被提升

函数的声明方式主要由两种：声明式和变量式。

**声明式会自动将声明放在前面并且执行赋值过程。而变量式则是先将声明提升，然后到赋值处再执行赋值。**比如:

```
function test() {
    foo(); // TypeError "foo is not a function"
    bar(); // "this will run!"
    var foo = function () { // function expression assigned to local variable 'foo'
        alert("this won't run!");
    }
    function bar() { // function declaration, given the name 'bar'
        alert("this will run!");
    }
}
test();
```

实际上等价于:

```
function test() {
    var foo;
    var bar;
    bar = function () { // function declaration, given the name 'bar'
        alert("this will run!");
    }

    foo(); // TypeError "foo is not a function"
    bar(); // "this will run!"

    foo = function () { // function expression assigned to local variable 'foo'
        alert("this won't run!");
    }
}
test();
```

*主要注意的地方：*带有命名的函数变量式声明，是不会提升到作用域范围内的，比如:

```
var baz = function spam() {};
baz(); // vaild
spam(); // ReferenceError "spam is not defined"
```

## 实战经验

**任何时候，请使用`var`声明变量, 并放置在作用域的顶端**.

工具推荐`JSLint`之类，帮助你验证语法的规范。

## 参考资料

- [JavaScript Scoping and Hoisting](http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html)
- [ECMScript Standard(PDF)](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)



# 运算符的优先级

任何一门语言都会遵守这样的规则。

## 参考资料

- [MDN: 运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
- [JS Comparison Table](https://dorey.github.io/JavaScript-Equality-Table/): if, ==, ===各种对比情况
- [代码之谜（三）- 运算符](http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-operator.html)



# 变量对象

> “JavaScript的基本类型有几种？”

红宝书上解释的五种基本类型：

- number
- string
- boolean
- undefined
- null

但是也有人认为是六种，加上object, 成为复杂数据类型。

## 基本类型（primitive types）

五种基本类型保存在内存中的栈中,大小固定,复制其变量时会创建这个值的一个副本。使用`typeof`区分。这些值是在底层上直接实现的，他们不是object，所以没有原型，没有构造函数。

```
var a = undefined;
var b = null;
var c = true;
var d = 'test';
var e = 10;
```

## 引用类型

引用类型的值是对象,保存在堆内存中。引用类型的变量实际上是一个指针,它保存在栈中,指向堆内存中的对象,复制引用类型变量实际是复制该指针,所以他们都指向同一个对象,用instanceof确定一个值是哪种引用类型。

## 内置对象、原生对象及宿主对象

内置对象和元素对象是被ECMAScript规范定义和实现的，两者之间的差异微不足道。所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。

注意，宿主对象可能是ES自身实现的，完全符合规范的语义。从这点来说，他们能称为“原生宿主”对象（尽快很理论），不过规范没有定义“原生宿主”对象的概念。

## 特殊包装类

- Boolean: 布尔对象
- String: 字符串对象
- Number: 数字对象

这些对象的创建，是通过相应的内置构造器创建，并且包含原生值作为其内部属性，这些对象可以转换省原始值，反之亦然。

```
var c = new Boolean(true);
var d = new String('test');
var e = new Number(10);

// 转换成原始值
// 使用不带new关键字的函数
с = Boolean(c);
d = String(d);
e = Number(e);

// 重新转换成对象
с = Object(c);
d = Object(d);
e = Object(e);
```

## typeof 返回值

实际应用是用来检测一个对象是否已经定义或者是否已经赋值:

```
Value               Class      Type
-------------------------------------
"foo"               String     string
1.2                 Number     number
true                Boolean    boolean
undefined           Undefined  undefined
new Function("")    Function   function
new String("foo")   String     object
new Number(1.2)     Number     object
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
```

返回的类型只有六种:

- string
- number
- boolean
- undefined
- object
- function

## instanceof 操作符

instanceof 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。如果用来比较内置类型，将会和 `typeof` 操作符 一样用处不大。

## Object.prototype.toString获取``[[class]]`

检测一个对象的类型，强烈推荐使用 Object.prototype.toString 方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，typeof 的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。 我们使用`Object.prototype.toString`方法:

```
Object.prototype.toString.call([])    // "[object Array]"
Object.prototype.toString.call({})    // "[object Object]"
Object.prototype.toString.call(2)    // "[object Number]"
```

## 参考资料

- [JavaScript中“基本类型”之争](http://www.cnblogs.com/snandy/archive/2013/01/02/2841899.html)
- [JavaScript秘密花园: 对象](https://bonsaiden.github.io/JavaScript-Garden/zh/#object)
- [深入理解JavaScript系列（12）：变量对象（Variable Object）](http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)



# undefined与null的区别

在常见的强类型语言中，通常有一个表示“空”的值，比如NULL。但是在Javascript中，空（或者叫“无值”）有两种选择：undefined和null。在Javascript中除了这两个值其他都是对象。其他的基本类型都有其对象的包装类型。但是，`typeof null`返回的是`object`，这是一个一直未修复的bug。

## 相似之处

都是完全不可变的，没有属性和方法，也不能给其属性赋值。事实上,试图访问或定义一个属性将会引发一个类型错误（TypeError）。正如他们的名字暗示的那样，他们是完全无效的值。

## 不同之处

一个重要的区别，服务于不同的目的和理由。区分这两个值，你可以认为undefined代表一个意想不到的没有值而null作为预期没有值的代表。

使用`Object.prototype.toString.call()`形式可以具体打印类型。

## undefined

undefined实际上代表了不存在的值（non-existence of a value）。

有许多的方法产生一个undefined值的代码。它通常遇到当试图访问一个不存在的值时。在这种情况下，在JavaScript这种动态的弱类型语言中，只会默认返回一个undefined值，而不是上升为一个错误:

- 任何声明变量时没有提供一个初始值，都会有一个为undefined的默认值
- 当试图访问一个不存在的对象属性或数组项时，返回一个undefined值
- 如果省略了函数的返回语句,返回undefined
- 函数调用时未提供的值结果将为undefined参数值
- void操作符也可以返回一个undefined值。像Underscore的库使用它作为一个防御式的类型检查，因为它是不可变的，可以在任何上下文依赖返回undefined
- undefined是一个预定义的全局变量(不像null关键字)初始化为undefined值

## null

通常用作一个空引用一个空对象的预期,就像一个占位符。typeof的这种行为已经被确认为一个错误，虽然提出了修正，出于后兼容的目的，这一点已经保持不变。 这就是为什么JavaScript环境从来没有设置一个值为null；它必须以编程方式完成。

使用null的情况:

- DOM，它是独立于语言的，不属于ECMAScript规范的范围。因为它是一个外部API，试图获取一个不存在的元素返回一个null值，而不是undefined。
- 如果你需要给一个变量或属性指定一个不变值，将它传递给一个函数，或者从一个函数返回null，null几乎总是最好的选择。
- JavaScript使用undefined并且程序员应该使用null。
- 通过分配null值，有效地清除引用，并假设对象没有引用其他代码，指定垃圾收集，确保回收内存。

## Object.prototype.toString调用过程

- 如果值是undefined，返回“[object Undefined]”。
- 如果这个值为null，则返回“[object Null]”。
- 让O作为调用ToObject同时传递this值作为参数的结果值。
- 让class是O的内部属性[[Class]]的值。
- 返回的结果连接三个字符串“[object ”，class，和“]”的结果的字符串值。

## 参考资料

- [探索JavaScript中Null和Undefined的深渊](http://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript)



# 内置对象与原生对象

## 参考资料

- [JavaScript原生对象及扩展](http://segmentfault.com/a/1190000002634958)



# 关于函数

理解函数的几种声明方式，以及其中的差异。

## 声明方式

ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符。规则如下：

> 函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ ... }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。

### 函数声明

如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。

```
function foo(){} // 声明，因为它是程序的一部分

(function(){
    function bar(){} // 声明，因为它是函数体的一部分
  })();
```

函数的声明方式会得到提升，且如果有相同的函数，会覆盖。比如:

```
if (true) {
    function foo(){ return 1; }
  }
  else {
    function foo(){ return 2; }
  }
  foo(); // 1

// 在ECMAScript的语法扩展中，有一个是函数语句, Gecko内核下可以使用,返回1
// 其他浏览器下，返回2
```

### 函数表达式

如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式。

还有一种函数表达式不太常见，就是**被括号括住的(function foo(){})**，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式。你可以会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：`eval('(' + json + ')')`，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。

```
var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分
new function bar(){}; // 表达式，因为它是new表达式
(function foo(){}); // 函数表达式：包含在分组操作符内
```

### 区别

- 函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值
- 函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式

## 命名函数表达式

在web开发中有个常用的模式是**基于对某种特性的测试来伪装函数定义**，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：

```
// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/) 
  var contains = (function() {
    var docEl = document.documentElement;

    if (typeof docEl.compareDocumentPosition != 'undefined') {
      return function(el, b) {
        return (el.compareDocumentPosition(b) & 16) !== 0;
      };
    }
    else if (typeof docEl.contains != 'undefined') {
      return function(el, b) {
        return el !== b && el.contains(b);
      };
    }
    return function(el, b) {
      if (el === b) return false;
      while (el != b && (b = b.parentNode) != null);
      return el === b;
    };
  })();
```

一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：

```
var f = function foo(){
   return typeof foo; // foo是在内部作用域内有效
 };
 // foo在外部用于是不可见的
 typeof foo; // "undefined"
 f(); // "function"
```

命名函数表达式的作用：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。特别是在匿名函数的时候比较有效。

## 函数的内存管理

如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。

## 参考资料

- [在JavaScript的Array数组中调用一组Function方法](http://ourjs.com/detail/548925908a34fa3204000002)
- [深入理解JavaScript系列（2）：揭秘命名函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html)



# 立即执行函数

了解完函数之后，我们介绍一下立刻调用函数，也就是我们常说的自执行函数。

## 什么是自执行

在JavaScript中，每个函数被调用时都会创建一个全新的上下文环境。因此，在函数内部定义的变量和函数就只能在函数内部访问，在外部无法访问，那么在该上下文环境中，调用的函数就提供了一个非常方便的方式来创建私有成员。也就是解释了JavaScript的作用域是`function-level`。

```
function makeCounter() {
    // 只能在makeCounter内部访问i
    var i = 0;

    return function () {
        console.log(++i);
    };
}
```

## 原理

在**一个表达式后面加上括号()**，该表达式会立即执行, 但是在**一个语句后面加上括号()**，是完全不一样的意思，他的只是分组操作符。

```
/*
 * 下面两种声明函数的方式，使用函数引用加上括号，可以立即调用函数
 */
var foo = function() {};
function foo() {};

/*
 * 解析器解析全局的function或者function内部function关键字的时候，默认是认为function声明，而不是function表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的function
 * 所以在函数声明后面直接加上括号，会出现语法错误。
 */
function (){ /* code */ }(); //期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称。

/*
 * 即使是函数声明，直接在后面使用括号，也不会立即执行。后面的括号相当于在函数声明后面加上分号，并且断行。后面的括号是分组运算符
 */

function foo(){}(); // 分组运算符需要表达式
```

理解了这些，我们只需要用大括弧将代码的代码全部括住就行了，**因为JavaScript里括弧`()`里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明。**

所以那些匿名函数附近使用括号或一些一元运算符的惯用法，就是来引导解析器，指明运算符附近是一个表达式。

## 实现方式

```
// 下面2个括弧()都会立即执行

(function () { /* code */ } ()); // 推荐使用这个
(function () { /* code */ })(); // 但是这个也是可以用的

// 由于括弧()和JS的&&，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的
// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了
// 不过，请注意下一章节的内容解释

var i = function () { return 10; } ();
true && function () { /* code */ } ();
0, function () { /* code */ } ();

// 如果你不在意返回值，或者不怕难以阅读
// 你甚至可以在function前面加一元操作符号

!function () { /* code */ } ();
~function () { /* code */ } ();
-function () { /* code */ } ();
+function () { /* code */ } ();

// 还有一个情况，使用new关键字,也可以用，但我不确定它的效率
// http://twitter.com/kuvos/status/18209252090847232

new function () { /* code */ }
new function () { /* code */ } () // 如果需要传递参数，只需要加上括弧()
```

## 自执行匿名函数和立即执行的函数表达式区别

自执行，顾名思义，自己执行自己的操作:

```
// 这是一个自执行的函数，函数内部执行自身，递归
function foo() { foo(); }

// 这是一个自执行的匿名函数，因为没有标示名称
// 必须使用arguments.callee属性来执行自己
var foo = function () { arguments.callee(); };

// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身
// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数
var foo = function () { foo(); };
```

我们倡导的说法是立即执行函数，所以自执行其实也是一个立即执行函数。

```
// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。
(function () { /* code */ } ());

// 为函数表达式添加一个标示名称，可以方便Debug
// 但一定命名了，这个函数就不再是匿名的了
(function foo() { /* code */ } ());

// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了
(function () { arguments.callee(); } ());
(function foo() { foo(); } ());
```

## 参考资料

- [深入理解JavaScript系列（4）：立即调用的函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html)
- [Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)



# 闭包

闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。

## 概念

首先了解一个JavaScript变量的作用域, 无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如:

```
function f1(){
　　　　var n=999;
　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}
　　}
```

函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

**所以**，我们说的闭包，就是能够在外部访问函数内部的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

## 用途

闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。

### 读取函数内部的变量

比如上面的例子

### 使变量的值始终保持在内存中

```
function f1(){
　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n++);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
```

这里我们在外部调用`result`函数，可以不断怎家内部的n值，实际上函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

**原因**: f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

### 用闭包模拟私有方法

JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。

下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：

```
var Counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }   
})();

alert(Counter.value()); /* 提示 0 */
Counter.increment();
Counter.increment();
alert(Counter.value()); /* 提示 2 */
Counter.decrement();
alert(Counter.value()); /* 提示 1 */
```

### 在循环中创建闭包

当我们为一组对象进行操作的时候，比如注册事件，如果我们这样写:

```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}
function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function() {
      showHelp(item.help);
    }
  }
}
setupHelp();
```

运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。该问题的原因在于在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量已经指向了 helpText 列表中的最后一项。

修改如下:

```
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function makeHelpCallback(help) {
  return function() {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Your e-mail address'},
      {'id': 'name', 'help': 'Your full name'},
      {'id': 'age', 'help': 'Your age (you must be over 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();
```

## 使用闭包的注意点

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

## 参考资料

- [JavaScript 权威指南(6): 闭包](http://www.html-js.com/article/Lan-Xiang-The-Definitive-Guide-to-product-JavaScript-JavaScript-6-The-Definitive-Guide-to-closure)
- [阮一峰: 学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
- [深入理解JavaScript系列（16）：闭包（Closures）](http://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html)



# 事件机制

JavaScript是一套使用事件机制较多的语言，特别是与DOM交互的时候。所以了解并理解事件机制就变得很必要了。

## 事件监听

### HTML内联属性

类似`<button onclick="alert('你点击了这个按钮');">点击这个按钮</button>`的方式，这种方式会使JS与HTML高度耦合，不利于开发和维护，不推荐使用。

### DOM属性绑定

使用DOM元素的`onXXX`属性设置，简单易懂，兼容性好。确定是只能绑定一个处理函数。

### 事件监听函数

使用事件监听函数`element.addEventListener(<event-name>, <callback>, <use-capture>);`，在 element 这个对象上面添加一个事件监听器，当监听到有 事件发生的时候，调用 这个回调函数。至于 这个参数，表示该事件监听是在“捕获”阶段中监听（设置为 true）还是在“冒泡”阶段中监听（设置为 false）。

## 移除事件监听

使用事件解除绑定方法:`element.removeEventListener(<event-name>, <callback>, <use-capture>);`

需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。

## 模拟触发事件

内置的时间也可以被JavaScript模拟触发，使用`dispatchEvent`方法。

## 自定义事件

与自定义事件的函数有 Event、CustomEvent 和 dispatchEvent。

### Event

直接自定义事件，使用 Event 构造函数：

```
var event = new Event('build');

// Listen for the event.
elem.addEventListener('build', function (e) { ... }, false);

// Dispatch the event.
elem.dispatchEvent(event);
```

### CustonEvent

CustomEvent 可以创建一个更高度自定义事件，还可以附带一些数据，具体用法如下：

```
var myEvent = new CustomEvent(eventname, options);
```

其中options可以是:

```
{
    detail: {
        ...
    },
    bubbles: true,
    cancelable: false
}
```

其中 detail 可以存放一些初始化的信息，可以在触发的时候调用。其他属性就是定义该事件是否具有冒泡等等功能。

### dispatchEvent

这个用于触发自定义的事件。

## 事件顺序

当我们给父子关系的元素都绑定了事件的时候，触发子元素的时候，这两个事件发生的前后顺序是如何的？这引开了我们关于事件顺序的讨论，其实一共有两种方式:

- Event Capturing(事件捕获)： NetScape所主张的方式
- Event Bubbling(事件冒泡)： Micsoft所主张的方式

这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个[规范](http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/)：首先进入事件捕获阶段->达到元素后->进入事件冒泡阶段。

开发者可以通过`addEventListener`函数的第三个参数设置事件触发的阶段，默认为false,冒泡阶段。而DOM1级别的事件绑定则只能在冒泡阶段触发。

## 事件代理

事件绑定后，检测顺序就会从被绑定的DOM下滑到触发的元素，再冒泡会绑定的DOM上。也就是说，如果你监听了一个DOM节点，那也就等于你监听了其所有的后代节点。

代理的意思就是只监听父节点的事件触发，以来代理对其后代节点的监听，而你需要做的只是通过`currentTarget`属性得到触发元素并作出回应。

使用事件代理意味着你可以节省大量重复的事件监听，以减少浏览器资源消耗。还有一个好处就是让HTML独立起来，比如之后还有要加子元素的需求，也不需要再为其单独加事件监听了。

## 事件的Event对象

当一个事件被触发的时候，会创建一个事件对象（Event Object），这个对象里面包含了一些有用的属性或者方法。事件对象会作为第一个参数，传递给我们的毁掉函数。我们可以使用下面代码，在浏览器中打印出这个事件对象：

```
    var btn = document.getElementsByTagName('button');
    btn[0].addEventListener('click', function(event) {
        console.log(event);
    }, false);
```

比较常用的几个属性和方法：

- type(string): 事件的名称，比如 “click”。
- target(node): 事件要触发的目标节点。
- currentTarget(node): 它就指向正在处理事件的元素：这恰是我们需要的。很不幸的是微软模型中并没有相似的属性, 你也可以使用”this”关键字。事件属性也提供了一个值可供访问:`event.currentTarget`。
- bubbles (boolean): 表明该事件是否是在冒泡阶段触发的。
- preventDefault (function): 这个方法可以禁止一切默认的行为，例如点击 a 标签时，会打开一个新页面，如果为 a 标签监听事件 click 同时调用该方法，则不会打开新页面。
- stopPropagation (function): 很多时候，我们触发某个元素，会顺带触发出它父级身上的事件，这有时候是我们不想要的，大多数我们想要的还是事件相互独立。所以我们可以选择阻止事件冒泡，使用`event.stopPropagation()`.
- stopImmediatePropagation (function): 与 stopPropagation 类似，就是阻止触发其他监听函数。但是与 stopPropagation 不同的是，它更加 “强力”，阻止除了目标之外的事件触发，甚至阻止针对同一个目标节点的相同事件
- cancelable (boolean): 这个属性表明该事件是否可以通过调用 event.preventDefault 方法来禁用默认行为。
- eventPhase (number): 这个属性的数字表示当前事件触发在什么阶段。
  - 0: none
  - 1: 捕获
  - 2: 目标
  - 3: 冒泡
- pageX 和 pageY (number): 这两个属性表示触发事件时，鼠标相对于页面的坐标。
- isTrusted (boolean): 表明该事件是浏览器触发（用户真实操作触发），还是 JavaScript 代码触发的。

## 事件的回调函数

事件绑定函数时，该函数会以当前元素为作用域执行,所以回调函数中的`this`是当前的DOM元素。如果我们需要指定作用域，可以选择:

- 使用匿名函数包裹回调函数
- 使用bind方法

## 事件列表

可以通过MDN查询，也可以在浏览器中输入:

```
for (i in window) {
  if ( /^on/.test(i)) { console.log(i); }
}
```

查看，你会发现提供的事件超过你想象的多！

### 常用事件

- `load` 资源加载完成时触发。这个资源可以是图片、CSS 文件、JS 文件、视频、document 和 window 等等。
- `DOMContentLoaded` DOM构建完毕的时候触发, jQuery的ready方法包裹的就是这个事件。
- `beforeunload` 当浏览者在页面上的输入框输入一些内容时，未保存、误操作关掉网页可能会导致输入信息丢失。当浏览者输入信息但未保存时关掉网页，我们就可以开始监听这个事件,这时候试图关闭网页的时候，会弹窗阻止操作，点击确认之后才会关闭。当然，如果没有必要，就不要监听，不要以为使用它可以为你留住浏览者。
- `resize` 当节点尺寸发生变化时，触发这个事件。通常用在 window 上，这样可以监听浏览器窗口的变化。通常用在复杂布局和响应式上。出于对性能的考虑，你可以使用函数 throttle 或者 debounce 技巧来进行优化，throttle 方法大体思路就是在某一段时间内无论多次调用，只执行一次函数，到达时间就执行；debounce 方法大体思路就是在某一段时间内等待是否还会重复调用，如果不会再调用，就执行函数，如果还有重复调用，则不执行继续等待。
- `error` 当我们加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发 error 事件，我们可以通过监听该事件来提示一个友好的报错或者进行其他处理。比如 JS 资源加载失败，则提示尝试刷新；图片资源加载失败，在图片下面提示图片加载失败等。该事件不会冒泡。因为子节点加载失败，并不意味着父节点加载失败，所以你的处理函数必须精确绑定到目标节点。

## IE浏览器下的情况

### IE下绑定事件

在 IE 下面绑定一个事件监听，在 IE9之前的版本中无法使用标准的 `addEventListener` 函数，而是使用自家的 `attachEvent`，具体用法：`element.attachEvent(<event-name>, <callback>);`

它只支持监听在冒泡阶段触发的事件，所以为了统一，在使用标准事件监听函数的时候，第三参数传递 false。

### IE下的Event事件

IE 中往回调函数中传递的事件对象与标准也有一些差异，你需要使用 window.event 来获取事件对象。所以你通常会写出下面代码来获取事件对象：

```
event = event || window.event
```

此外还有一些事件属性有差别，比如比较常用的 event.target 属性，IE 中没有，而是使用 event.srcElement 来代替。如果你的回调函数需要处理触发事件的节点，那么需要写:

```
node = event.srcElement || event.target;
```

## 参考资料

- [Introduction to Events](http://www.quirksmode.org/js/introevents.html)
- [Event order](http://www.quirksmode.org/js/events_order.html)
- [MDN: Event](https://developer.mozilla.org/en-US/docs/Web/API/Event#Properties)
- [W3C: Document Object Model (DOM) Level 3 Events Specification](http://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
- [你若触发，我就处理——浅谈JavaScript的事件响应](http://chajn.org/project/javascript-events-responding-user/)
- [最详细的JavaScript和事件解读](http://www.admin10000.com/document/6089.html)



# 原型继承

JavaScript不是真正意义上的面向对象语言，没有提供传统的继承方式,它提供的是一种叫做原型继承的方式。但是它拥有面向对象和函数式的编程特点,理解原型继承，对我们使用JS来实现面向对象很有帮助。

## 原型

在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个`__proto__`属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个`__proto__`指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。

结合一下图，认真思考下:

![prototype-lauout](https://leohxj.gitbooks.io/front-end-database/content/javascript-basic/assets/prototype-lauout.jpg)

理解几点:

- `prototype`: 在函数身上，指向原型对象
- `__proto__`: 在对象身上（包括函数创建的对象, 函数本身和原型对象），指向自身的原型
- `constructor`: 在原型对象上，指向构造函数, 在多级继承的时候，指明构造函数方便在对象上扩展原型属性
- `Object.__protp__`为null: 原型的顶端

## 原型使用方式

### 方式一

通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型。

```
var Calculator = function (decimalDigits, tax) {
    this.decimalDigits = decimalDigits;
    this.tax = tax;
};
Calculator.prototype = {
    add: function (x, y) {
    return x + y;
},

subtract: function (x, y) {
    return x - y;
    }
};
//alert((new Calculator()).add(1, 3));
```

### 方式二

赋值原型prototype的时候使用function立即执行的表达式来赋值，即如下格式:`Calculator.prototype = function () { } ();`, 可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果。

```
Calculator.prototype = function () {
            add = function (x, y) {
                return x + y;
            },

            subtract = function (x, y) {
                return x - y;
            }
            return {
                add: add,
                subtract: subtract
            }
        } ();

        //alert((new Calculator()).add(11, 3));
```

### 方式三

分别设置原型对象:

```
var Calculator = function (decimalDigits, tax) {
    this.decimalDigits = decimalDigits;
    this.tax = tax;
};
Calculator.prototype.add = function (x, y) {
    return x + y;
};

Calculator.prototype.subtract = function (x, y) {
    return x - y;
};
```

## 原型的作用

最主要的一点是数据共享，创建对象的时候，我们会把公共的方法和属性挂载到原型上，避免资源浪费。

## 原型链

原型对象也有自己的原型，直到对象的原型为 null 为止（也就是没有原型）。这种一级一级的链结构就称为原型链。原型继承的模型就是JavaScript实现继承的原理。**真正形成原型链的是每个对象的`__proto__`属性，而不是函数的prototype属性，这是很重要的。**

```
function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置Bar的prototype属性为Foo的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = 'Hello World';

// 修正Bar.prototype.constructor为Bar本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建Bar的一个新实例

// 原型链
test [Bar的实例]
    Bar.prototype [Foo的实例] 
        { foo: 'Hello World' }
        Foo.prototype
            {method: ...};
            Object.prototype
                {toString: ... /* etc. */};
```

上面的例子中，test 对象从 `Bar.prototype` 和 `Foo.prototype` 继承下来；因此， 它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在原型上的 Foo 实例属性 value。 需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；因此，所有的 Bar 实例都会共享相同的 value 属性。

### 原型链使用方式

通常情况下，我们在实现继承的时候，会将一个函数的原型指向另一个函数的实例对象，而不是函数的原型本身。因为这将会导致两个对象共享相同的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。

也不要使用 `Bar.prototype = Foo`，因为这不会执行 Foo 的原型，而是指向函数 Foo。 因此原型链将会回溯到 `Function.prototype` 而不是 `Foo.prototype`，因此 method 将不会在 Bar 的原型链上。

### 重写原型方法

在使用第三方JS类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的一个或者多个属性或function，我们可以通过继续声明的同样的add代码的形式来达到覆盖重写前面的add功能，代码如下：

```
Calculator.prototype.add = function (x, y) {
    return x + y + this.tax;
};
```

原理就是让在原型链上的查找能够就近解决。需要注意的是重写的代码需要放在最后，这样才能覆盖前面的代码。

### 属性查找

当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。

到查找到达原型链的顶部, 也就是 `Object.prototype`, （因为Object的原型的`__proto__`是null） 但是仍然没有找到指定的属性，就会返回 undefined。

### `hasOwnProperty`函数

为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 `Object.prototype` 的 `hasOwnProperty`方法。它是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。

在使用`for...in`遍历属性的时候，可以方便过滤是否是自身属性。

## 原型继承与类继承的区别

| 基于类的继承                                              |                           原型继承                           |
| --------------------------------------------------------- | :----------------------------------------------------------: |
| 类是不可变的。在运行时，你无法修改或者添加新的方法        |        原型是灵活的。它们可以是不可变的也可以是可变的        |
| 类可能会不支持多重继承                                    |                   对象可以继承多个原型对象                   |
| 基于类的继承比较复杂。你需要使用抽象类，接口和final类等等 | 原型继承比较简洁。你只有对象，你只需要对对象进行扩展就可以了 |

## 创建方式

### new 运算符是如何工作的

造物者 Brendan Eich 想让JS和传统的面向对象的编程语言差不太多，如Java和C++。在这些语言里，我们采用 new 运算符来给类实例化一个新的对象。所以他在JS里写了一个 new 运算符:

- C++里有用来初始化实例属性的构造函数概念，因此 new 运算符必须针对函数。
- 我们需要将对象的方法放到一个地方去，既然我们在用原型语言，我们就把它放到函数的原型属性中去。

new 运算符接受一个函数 F 及其参数：new F(arguments...)。这一过程分为三步：

1. 创建类的实例。这步是把一个空的对象的 **proto** 属性设置为 F.prototype 。
2. 初始化实例。函数 F 被传入参数并调用，关键字 this 被设定为该实例。
3. 返回实例。

**注意构造函数中的this关键字，它就代表了新创建的实例对象。**

看个实例:

```
function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype = {
    print: function () { console.log(this.x, this.y); }
};

var p1 = new Point(10, 20);
p1.print(); // 10 20
console.log(p1 instanceof Point); // true

var p2 = New (Point)(10, 20);
p2.print(); // 10 20
console.log(p2 instanceof Point); // true
```

### 构造模式和原型模式对比

| 构造模式                                         |                     原型模式                     |
| ------------------------------------------------ | :----------------------------------------------: |
| 函数式特点无法与new关键字一起使用                |          函数式特点可以与create结合使用          |
| 忘记使用new会导致无法预期的bug并且会污染全局变量 | 由于create是一个函数，所以程序总是会按照预期工作 |
| 使用构造函数的原型继承比较复杂并且混乱           |            使用原型的原型继承简洁易懂            |

## 参考资料

- [MDN: 继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain)
- [【翻译】JavaScript原型继承工作原理](http://www.ituring.com.cn/article/56184)
- [Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)
- [为什么原型继承很重要](http://segmentfault.com/blog/kk_470661/1190000002596600)
- [再谈Javascript原型继承](http://segmentfault.com/blog/kk_470661/1190000000766541)
- [深入理解JavaScript系列（5）：强大的原型和原型链](http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html)
- [JS秘密花园: 原型](http://bonsaiden.github.io/JavaScript-Garden/zh/#object.prototype)
- [Javascript 原型拓扑](http://blog.mutoo.im/2015/01/topology-of-javascript-prototype.html)



# 详解this

习惯了高级语言的你或许觉得JavaScript中的this跟Java这些面向对象语言相似，保存了实体属性的一些值。其实不然。将它视作幻影魔神比较恰当，手提一个装满未知符文的灵龛。

## 全局this

浏览器宿主的全局环境中，this指的是window对象。

```
<script type="text/javascript">
    console.log(this === window); //true
</script>
```

浏览器中在全局环境下，使用var声明变量其实就是赋值给this或window。

```
<script type="text/javascript">
    var foo = "bar";
    console.log(this.foo); //logs "bar"
    console.log(window.foo); //logs "bar"
</script>
```

任何情况下，创建变量时没有使用var或者let(ECMAScript 6)，也是在操作全局this。

```
<script type="text/javascript">
    foo = "bar";

    function testThis() {
      foo = "foo";
    }

    console.log(this.foo); //logs "bar"
    testThis();
    console.log(this.foo); //logs "foo"
</script>
```

Node命令行（REPL）中，this是全局命名空间。可以通过global来访问。

```
> this
{ ArrayBuffer: [Function: ArrayBuffer],
  Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },
  Uint8Array: { [Function: Uint8Array] BYTES_PER_ELEMENT: 1 },
  ...
> global === this
true
```

在Node环境里执行的JS脚本中，this其实是个空对象，有别于global。

```
console.log(this);
console.log(this === global);

###
$ node test.js
{}
false
```

但在命令行里进行求值却会赋值到this身上。

```
> var foo = "bar";
> this.foo
bar
> global.foo
bar
```

在Node里执行的脚本中，创建变量时没带var或let关键字，会赋值给全局的global但不是this（译注：上面已经提到this和global不是同一个对象，所以这里就不奇怪了）。

```
foo = "bar";
console.log(this.foo);
console.log(global.foo);

###
$ node test.js
undefined
bar
```

但在Node命令行里，就会赋值给两者了。

**简单来说，Node脚本中global和this是区别对待的，而Node命令行中，两者可等效为同一对象。**

## 函数或方法里的this

除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。

```
<script type="text/javascript">
    foo = "bar";

    function testThis() {
      this.foo = "foo";
    }

    console.log(this.foo); //logs "bar"
    testThis();
    console.log(this.foo); //logs "foo"
</script>
```

测试结果：

```
$ node test.js
bar
foo
```

还有个例外，就是使用了"use strict";。此时this是undefined。

```
<script type="text/javascript">
    foo = "bar";

    function testThis() {
      "use strict";
      this.foo = "foo";
    }

    console.log(this.foo); //logs "bar"
    testThis();  //Uncaught TypeError: Cannot set property 'foo' of undefined 
</script>
```

当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。

```
<script type="text/javascript">
    foo = "bar";

    function testThis() {
      this.foo = "foo";
    }

    console.log(this.foo); //logs "bar"
    new testThis();
    console.log(this.foo); //logs "bar"

    console.log(new testThis().foo); //logs "foo"
</script>
```

通常我将这个新的上下文称作实例。

## 原型中的this

函数创建后其实以一个函数对象的形式存在着。既然是对象，则自动获得了一个叫做prototype的属性，可以自由地对这个属性进行赋值。当配合new关键字来调用一个函数创建实例后，此刻便能直接访问到原型身上的值。

```
function Thing() {
    console.log(this.foo);
}

Thing.prototype.foo = "bar";

var thing = new Thing(); //logs "bar"
console.log(thing.foo);  //logs "bar"
```

当通过new的方式创建了多个实例后，他们会共用一个原型。比如，每个实例的this.foo都返回相同的值，直到this.foo被重写。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    console.log(this.foo);
}
Thing.prototype.setFoo = function (newFoo) {
    this.foo = newFoo;
}

var thing1 = new Thing();
var thing2 = new Thing();

thing1.logFoo(); //logs "bar"
thing2.logFoo(); //logs "bar"

thing1.setFoo("foo");
thing1.logFoo(); //logs "foo";
thing2.logFoo(); //logs "bar";

thing2.foo = "foobar";
thing1.logFoo(); //logs "foo";
thing2.logFoo(); //logs "foobar";
```

在实例中，this是个特殊的对象，而this自身其实只是个关键字。你可以把this想象成在实例中获取原型值的一种途径，同时对this赋值又会覆盖原型上的值。完全可以将新增的值从原型中删除从而将原型还原为初始状态。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    console.log(this.foo);
}
Thing.prototype.setFoo = function (newFoo) {
    this.foo = newFoo;
}
Thing.prototype.deleteFoo = function () {
    delete this.foo;
}

var thing = new Thing();
thing.setFoo("foo");
thing.logFoo(); //logs "foo";
thing.deleteFoo();
thing.logFoo(); //logs "bar";
thing.foo = "foobar";
thing.logFoo(); //logs "foobar";
delete thing.foo;
thing.logFoo(); //logs "bar";
```

或者不通过实例，直接操作函数的原型。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    console.log(this.foo, Thing.prototype.foo);
}

var thing = new Thing();
thing.foo = "foo";
thing.logFoo(); //logs "foo bar";
```

同一函数创建的所有实例均共享一个原型。如果你给原型赋值了一个数组，那么所有实例都能获取到这个数组。除非你在某个实例中对其进行了重写，实事上是进行了覆盖。

```
function Thing() {
}
Thing.prototype.things = [];


var thing1 = new Thing();
var thing2 = new Thing();
thing1.things.push("foo");
console.log(thing2.things); //logs ["foo"]
```

通常上面的做法是不正确的（译注：改变thing1的同时也影响了thing2）。如果你想每个实例互不影响，那么请在函数里创建这些值，而不是在原型上。

```
function Thing() {
    this.things = [];
}


var thing1 = new Thing();
var thing2 = new Thing();
thing1.things.push("foo");
console.log(thing1.things); //logs ["foo"]
console.log(thing2.things); //logs []
```

多个函数可以形成原型链，这样this便会在原型链上逐步往上找直到找到你想引用的值。

```
function Thing1() {
}
Thing1.prototype.foo = "bar";

function Thing2() {
}
Thing2.prototype = new Thing1();


var thing = new Thing2();
console.log(thing.foo); //logs "bar"
```

很多人便是利用这个特性在JS中模拟经典的对象继承。**注意原型链底层函数中对this的操作会覆盖上层的值。**

```
function Thing1() {
}
Thing1.prototype.foo = "bar";

function Thing2() {
    this.foo = "foo";
}
Thing2.prototype = new Thing1();

function Thing3() {
}
Thing3.prototype = new Thing2();


var thing = new Thing3();
console.log(thing.foo); //logs "foo"
```

我习惯将赋值到原型上的函数称作方法。上面某些地方便使用了方法这样的字眼，比如logFoo方法。这些方法中的this同样具有在原型链上查找引用的魔力。通常将最初用来创建实例的函数称作构造函数。

原型链方法中的this是从实例中的this开始住上查找整个原型链的。也就是说，如果原型链中某个地方直接对this进行赋值覆盖了某个变量，那么我们拿到 的是覆盖后的值。

```
function Thing1() {
}
Thing1.prototype.foo = "bar";
Thing1.prototype.logFoo = function () {
    console.log(this.foo);
}

function Thing2() {
    this.foo = "foo";
}
Thing2.prototype = new Thing1();


var thing = new Thing2();
thing.logFoo(); //logs "foo";
```

在JavaScript中，函数可以嵌套函数，也就是你可以在函数里面继续定义函数。但内层函数是通过闭包获取外层函数里定义的变量值的，而不是直接继承this。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    var info = "attempting to log this.foo:";
    function doIt() {
        console.log(info, this.foo);
    }
    doIt();
}


var thing = new Thing();
thing.logFoo();  //logs "attempting to log this.foo: undefined"
```

上面示例中，doIt 函数中的this指代是全局作用域或者是undefined如果使用了"use strict";声明的话。对于很多新手来说，理解这点是非常头疼的。

还有更奇葩的。把实例的方法作为参数传递时，实例是不会跟着过去的。也就是说，此时方法中的this在调用时指向的是全局this或者是undefined在声明了"use strict"时。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {  
    console.log(this.foo);   
}

function doIt(method) {
    method();
}


var thing = new Thing();
thing.logFoo(); //logs "bar"
doIt(thing.logFoo); //logs undefined
```

所以很多人习惯将this缓存起来，用个叫self或者其他什么的变量来保存，以将外层与内层的this区分开来。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    var self = this;
    var info = "attempting to log this.foo:";
    function doIt() {
        console.log(info, self.foo);
    }
    doIt();
}


var thing = new Thing();
thing.logFoo();  //logs "attempting to log this.foo: bar"
```

但上面的方式不是万能的，在将方法做为参数传递时，就不起作用了。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () { 
    var self = this;
    function doIt() {
        console.log(self.foo);
    }
    doIt();
}

function doItIndirectly(method) {
    method();
}


var thing = new Thing();
thing.logFoo(); //logs "bar"
doItIndirectly(thing.logFoo); //logs undefined
```

解决方法就是传递的时候使用bind方法显示指明上下文，bind方法是所有函数或方法都具有的。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () { 
    console.log(this.foo);
}

function doIt(method) {
    method();
}


var thing = new Thing();
doIt(thing.logFoo.bind(thing)); //logs bar
```

同时也可以使用apply或call 来调用该方法或函数，让它在一个新的上下文中执行。

```
function Thing() {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () { 
    function doIt() {
        console.log(this.foo);
    }
    doIt.apply(this);
}

function doItIndirectly(method) {
    method();
}


var thing = new Thing();
doItIndirectly(thing.logFoo.bind(thing)); //logs bar
```

使用bind可以任意改变函数或方法的执行上下文，即使它没有被绑定到一个实例的原型上。

```
function Thing() {
}
Thing.prototype.foo = "bar";


function logFoo(aStr) {
    console.log(aStr, this.foo);
}


var thing = new Thing();
logFoo.bind(thing)("using bind"); //logs "using bind bar"
logFoo.apply(thing, ["using apply"]); //logs "using apply bar"
logFoo.call(thing, "using call"); //logs "using call bar"
logFoo("using nothing"); //logs "using nothing undefined"
```

避免在构造函数中返回作何东西，因为返回的东西可能覆盖本来该返回的实例。

```
function Thing() {
    return {};
}
Thing.prototype.foo = "bar";


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}


var thing = new Thing();
thing.logFoo(); //Uncaught TypeError: undefined is not a function
```

但，如果你在构造函数里返回的是个原始值比如字符串或者数字什么的，上面的错误就不会发生了，返回语句将被忽略。所以最好别在一个将要通过new来调用的构造函数中返回作何东西，即使你是清醒的。如果你想实现工厂模式，那么请用一个函数来创建实例，并且不通过new来调用。当然这只是个人建议。

诚然，你也可以使用Object.create从而避免使用new。这样也能创建一个实例。

```
function Thing() {
}
Thing.prototype.foo = "bar";


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}


var thing =  Object.create(Thing.prototype);
thing.logFoo(); //logs "bar"
```

这种方式不会调用该构造函数。

```
function Thing() {
    this.foo = "foo";
}
Thing.prototype.foo = "bar";


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}


var thing =  Object.create(Thing.prototype);
thing.logFoo(); //logs "bar"
```

正因为Object.create没有调用构造函数，这在当你想实现一个继承时是非常有用的，随后你可能想要重写构造函数。

```
function Thing1() {
    this.foo = "foo";
}
Thing1.prototype.foo = "bar";

function Thing2() {
    this.logFoo(); //logs "bar"
    Thing1.apply(this);
    this.logFoo(); //logs "foo"
}
Thing2.prototype = Object.create(Thing1.prototype);
Thing2.prototype.logFoo = function () {
    console.log(this.foo);
}

var thing = new Thing2();
```

## 对象中的this

可以在对象的任何方法中使用this来访问该对象的属性。这与用new得到的实例是不一样的。

```
var obj = {
    foo: "bar",
    logFoo: function () {
        console.log(this.foo);
    }
};

obj.logFoo(); //logs "bar"
```

注意这里并没有使用new，也没有用Object.create，更没有函数的调用来创建对象。也可以将函数绑定到对象，就好像这个对象是一个实例一样。

```
var obj = {
    foo: "bar"
};

function logFoo() {
    console.log(this.foo);
}

logFoo.apply(obj); //logs "bar"
```

此时使用this没有向上查找原型链的复杂工序。通过this所拿到的只是该对象身上的属性而以。

```
var obj = {
    foo: "bar",
    deeper: {
        logFoo: function () {
            console.log(this.foo);
        }
    }
};

obj.deeper.logFoo(); //logs undefined
```

也可以不通过this，直接访问对象的属性。

```
var obj = {
    foo: "bar",
    deeper: {
        logFoo: function () {
            console.log(obj.foo);
        }
    }
};

obj.deeper.logFoo(); //logs "bar"
```

## DOM 事件回调中的this

在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。

```
function Listener() {
    document.getElementById("foo").addEventListener("click",
       this.handleClick);
}
Listener.prototype.handleClick = function (event) {
    console.log(this); //logs "<div id="foo"></div>"
}

var listener = new Listener();
document.getElementById("foo").click();
```

除非你通过bind人为改变了事件处理器的执行上下文。

```
function Listener() {
    document.getElementById("foo").addEventListener("click", 
        this.handleClick.bind(this));
}
Listener.prototype.handleClick = function (event) {
    console.log(this); //logs Listener {handleClick: function}
}

var listener = new Listener();
document.getElementById("foo").click();
```

## HTML中的this

HTML标签的属性中是可能写JS的，这种情况下this指代该HTML元素。

```
<div id="foo" onclick="console.log(this);"></div>
<script type="text/javascript">
document.getElementById("foo").click(); //logs <div id="foo"...
</script>
```

## 重写this

无法重写this，因为它是一个关键字。

```
function test () {
    var this = {};  // Uncaught SyntaxError: Unexpected token this 
}
```

## eval中的this

eval 中也可以正确获取当前的 this。

```
function Thing () {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    eval("console.log(this.foo)"); //logs "bar"
}

var thing = new Thing();
thing.logFoo();
```

这里存在安全隐患。最好的办法就是避免使用eval。

使用Function关键字创建的函数也可以获取this：

```
function Thing () {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = new Function("console.log(this.foo);");

var thing = new Thing();
thing.logFoo(); //logs "bar"
```

## 使用with时的this

使用with可以将this人为添加到当前执行环境中而不需要显示地引用this。

```
function Thing () {
}
Thing.prototype.foo = "bar";
Thing.prototype.logFoo = function () {
    with (this) {
        console.log(foo);
        foo = "foo";
    }
}

var thing = new Thing();
thing.logFoo(); // logs "bar"
console.log(thing.foo); // logs "foo"
```

正如很多人认为的那样，使用with是不好的，因为会产生歧义。

## jQuery中的this

一如HTML DOM元素的事件回调，jQuery库中大多地方的this也是指代的DOM元素。页面上的事件回调和一些便利的静态方法比如$.each 都是这样的。

```
<div class="foo bar1"></div>
<div class="foo bar2"></div>
<script type="text/javascript">
$(".foo").each(function () {
    console.log(this); //logs <div class="foo...
});
$(".foo").on("click", function () {
    console.log(this); //logs <div class="foo...
});
$(".foo").each(function () {
    this.click();
});
</script>
```

## 传递 this

如果你用过underscore.js或者lo-dash你便知道，这两个库中很多方法你可以传递一个参数来显示指定执行的上下文。比如_.each。自ECMAScript 5 标准后，一些原生的JS方法也允许传递上下文，比如forEach。事实上，上文提到的bind，apply还有call 已经给我们手动指定函数执行上下文的能力了。

```
function Thing(type) {
    this.type = type;
}
Thing.prototype.log = function (thing) {
    console.log(this.type, thing);
}
Thing.prototype.logThings = function (arr) {
   arr.forEach(this.log, this); // logs "fruit apples..."
   _.each(arr, this.log, this); //logs "fruit apples..."
}

var thing = new Thing("fruit");
thing.logThings(["apples", "oranges", "strawberries", "bananas"]);
```

这样可以使得代码简洁些，不用层层嵌套bind，也不用不断地缓存this。

一些编程语言上手很简单，比如Go语言手册可以被快速读完。然后你差不多就掌握这门语言了，只是在实战时会有些小的问题或陷阱在等着你。

而JavaScript不是这样的。手册难读。非常多缺陷在里面，以至于人们抽离出了它好的部分（The Good Parts）。最好的文档可能是MDN上的了。所以我建议你看看他上面关于this的介绍，并且始终在搜索JS相关问题时加上"mdn" 来获得最好的文档资料。静态代码检查也是个不错的工具，比如jshint。

## 参考资料

- [all this](http://bjorn.tipling.com/all-this)
- [详解this](http://www.cnblogs.com/Wayou/p/all-this.html)



# 在JavaScript中一切都是对象吗？

“在JavaScript中的一切都是对象”这个说法一直让我困惑。他们指的是什么？一个函数或者数组，它们怎么同时也是一个对象？在我们解答这个问题前，我们需要知道JavaScript是如何对不同数据类型归类的。

## 数据类型

在JavaScript中，有两个数据类型：基本类型和对象类型（对象类型有时候也被称为引用类型）。

### 基本类型

Number, String, Boolean, null, undefined

### 对象类型

Function, Object, Array

根据这个分类，这个问题的简单答案是：JavaScript中，并非一切值都是对象。是只有属于对象类型的值才是对象。也可以认为，任何非基本类型的都是对象类型。但是基本类型和对象类型有什么区别呢？更重要的是，人们所说的“所有”或“几乎所有”的JavaScript类似都是对象的真正含义是什么？这里说说主要的两个区别：可变性和比较。

## Mutability可变性

根据我的经验，人们说的值是“类似对象”的真实含义是因为他们的可变性，更具体的说，是支持添加和删除属性。例如，因为函数和数组属于对象类型，你可以像对象一样给它们添加属性。

```
var func = function() {};
func.firstName = "Andrew";
func.firstName; // "Andrew"

var arry = [];
arry.age = 26;
arry.age; // 26
```

可变性开启了各种精彩的使用方式，也是理解原型和构造函数是如何工作的关键。

但是基本类型是不可变的，我们无法给它们添加属性。如下面代码所示，即使我们给基本类型添加了属性，解析器会无法在下一步读取它们的值。

```
var me = "Andrew";
me.lastname = "Robbins";
me.lastname; // undefined

var num = 10;
num.prop = 11;
num.prop; // undefined
```

在这一点上，基本类型的值无法改变的真正含义，需要在更基本的层面检查问题，如下代码所示:

```
1 = 2; // ReferenceError
```

这似乎是一个愚蠢的例子，但是我认为能反映出我们现在讨论的可变性，当你在JavaScript控制器中输入数字 1，编译器会给其分配基本类型，所以当你尝试将数字1改变成数字2会失败。

## 比较和传递

除了可变性，另外一个基本类型和对象类型重要的区别是他们在程序中比较和传递的方式。基本类型通过值来比较，而对象类型通过引用来比较，这是什么意思呢？我们先看看基本类型，如下代码所示：

```
"a" === "a"; // true
```

因为值“a”等于“a”所以为true，当我们在图中引入变量会发生什么呢？除了将一个基本类型储存在变量中什么也没发生。

```
var a = "a",
    b = "a";

a === b; // true
```

当基本类型通过值来比较，结果为true，变量a的值正好等于变量b的值，换句话说，”a”等于”a”。但是看看下面这个例子，如果我们在对象类型中应用相同的例子，我们会得到相反的结果。

```
var a = {name: "andrew"},
    b = {name: "andrew"};

a === b; // false
```

为什么会这样呢？如果想要两者比较为真需要对象类型要引用同样的类型。通过以上的例子，我们给变量b创建一个新的对象。就像David Flanagan说过：**我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。**

那我们这样传值会发生什么？

```
var a = {name: "andrew"},
    b = a;

b.name = "robbins";

a === b; // true
```

这个可能开始看上去很奇怪，但是仔细看看发生了什么，因为对象是对象类型的一部分，它比较的值是按引用进行传递。引用的是相同的底层对象。在以上的例子中，我们设置b等于a。并没有创建新对象，我们只是简单地创建了一个对其他对象的引用。从另一个方面来看我们是将变量b指向a，所以当我们改变b的name属性，我们同样改变了a的name属性。

如果将相同的例子应用在基本类型上呢？

```
var a = "Andrew",
    b = a;

b = "Robbins";

a === b; // false
```

当我们设置b等于a，请记住基本类型通过值来传递和比较，我们实际上另外创建了一个a的拷贝，所以我们改变b的值再跟a比较，两个值是不一样的。

## Wrapper Objects包装对象

有些人会说：“好，如果基本类型不是对象，为什么我们可以调用他们的方法呢” 回答是包装对象。

当你尝试调用基本类型的方法，JavaScript在幕后做了一个巧妙的处理，将你的基本类型的值转换成临时对象用于构造函数，决定使用哪个构造函数取决于你尝试改变的基本类型的值，在String中调用.length会使用string()构造函数临时将基本类型转变成对象—允许你使用length方法而改变它，这个临时对象被称为包装对象。

有趣的是，null和undefined这两个基本类型不能调用这样的方法，否则会提示类型错误。

我们可以使用typeof来区分：

```
typeof "s"; // "string"
typeof new String(s); // "object"
```

**备注：**在执行typeof null 时js编译器会返回object，是显而易见的bug。

```
typeof null // "object"
```

当然，考虑到JavaScript是用10天写出来（http://www.quora.com/In-which-10-days-of-May-did-Brendan-Eich-write-JavaScript-Mocha-in-1995），就不过多去担忧了 :) 。

此外，我们也需要了解基本类型的属性是只读和临时的。

```
var hello = "hello";
hello.slice(1); // "ello" (Here we're actually calling slice not on hello, but of a copy of hello)
hello; // "hello"
```

## Summary总结

JavaScript的值可以分为两种类型：基本类型和对象类型，基本类型有：String, Number, Boolean, Symbol, undefined 和 null.，对象类型有Function, Object 和 Array.

基本类型和对象类型的区别在于可变性和比较的方式以及程序中传值。

基本类型是不可变的，换种说法就是它们的值不能改变。对比而言，对象类型是可变的，它们的值可以更新和改变。

基本类型可以按值比较，当我们把一个基本类型赋值给另外一个基本类型，是复制了一个值。而对象这是通过引用进行比较，引用的是什么呢？引用的是底层对象。当我们赋值一个对象给另一个对象时。引用指针就创建了。在这个情况下，改变一个对象的值将更新另外一个对象的值。

当我们尝试在基本类型的值中调用方法时，JavaScript使用包装对象来临时控制基本类型，导致对象变为只读的并在垃圾回收后执行。

## 参考资料

- [在JavaScript中一切都是对象吗？](http://web.jobbole.com/82016/)



# DOM操作

虽然JavaScript可以运行在服务器端了，但是我们最常用的还是与DOM打交道。

## 参考资料

- [JavaScript操作DOM的那些坑](http://mp.weixin.qq.com/s?__biz=MjM5MTcwNjE5OQ==&mid=204529550&idx=1&sn=fa05be0715b8bafdf90cc4bacba451c6#rd)
- [通俗易懂的来讲讲DOM](http://www.cnblogs.com/season-huang/p/4322451.html)



# JSON对象

> JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.

JSON只是一个数据交换语言，只有我们将之用在string上下文的时候它才叫JSON。

## 什么是JSON

我们通常误以为JavaScript里面的对象字面值是JSON。它只不过是“形似”而已。实际上只有当这样的字面值是字符串的时候，才是JSON对象。比如：

```
// 这是JSON字符串
var foo = '{ "prop": "val" }';

// 这是对象字面量
var bar = { "prop": "val" };
```

而且要注意，JSON有非常严格的语法，在string上下文里`{ "prop": "val" }` 是个合法的JSON，但`{ prop: "val" }`和`{ 'prop': 'val' }`确实不合法的。所有属性名称和它的值都必须用双引号引住，不能使用单引号。另外，即便你用了转义以后的单引号也是不合法的。

## 序列化与反序列化

2个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用string字符串因为string在很多语言里解析的方式都差不多。所以在JavaScript里面，也提供了一个`JSON`对象，目前有2个静态方法:

- `JSON.parse`: 用来将JSON字符串反序列化成对象
- `JSON.stringify`:用来将对象序列化成JSON字符串

## 参考资料

- [JSON](http://json.org/)
- [深入理解JavaScript系列（9）：根本没有“JSON对象”这回事！](http://www.cnblogs.com/TomXu/archive/2012/01/11/2311956.html)
- [JSON简介以及用法汇总](http://www.cnblogs.com/zichi/p/4360219.html)



# JavaScript进阶

初级部分的目标是达到使用层面的掌握，进阶部分我希望能深入了解一下原理，顺便讲解JS的高级用法，和一些工具。

## 参考资料

- [深入理解JavaScript系列](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)



# 理解执行环境与作用域链

函数调用都有与之相关的作用域和上下文。从根本上说，范围是基于函数(function-based)而上下文是基于对象(object-based)。换句话说，作用域是和每次函数调用时变量的访问有关，并且每次调用都是独立的。上下文总是关键字 this 的值，是调用当前可执行代码的对象的引用。

## 执行上下文栈(Execution Context Stack)

在ECMASscript中的代码有三种类型：global, function和eval。

每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。

注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。

一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。

当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。

## 执行上下文(Execution Context)

也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。

### 变量对象(Variable Object)

变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。

进入执行上下文时，VO的初始化过程具体如下：

- 函数的形参（当进入函数执行上下文时） 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined
- 函数声明（FunctionDeclaration, FD） 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值
- 变量声明（var，VariableDeclaration） 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。

执行代码的时候，VO的一些Undefined值会被确定。

### 活动对象(activation object)

当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。

即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。

AO是在进入函数的执行上下文时创建的，并为该对象初始化一个arguments属性，该属性的值为Arguments对象。

### 作用域链(scope chain)

作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。JS的语法风格和C/C++类似, 但作用域的实现却和C/C++不同，并非用“堆栈”方式，而是使用列表，具体过程如下(ECMA262中所述):

- 任何执行上下文时刻的作用域, 都是由作用域链(scope chain, 后面介绍)来实现.
- 在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.
- 在一个函数对象被调用的时候，会创建一个**活动对象(也就是一个对象)**, 然后对于每一个函数的形参，都命名为该活动对象的命名属性, 然后将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中.

在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。

当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。

## 闭包(Closures)

## 参考资料

- [深入理解JavaScript系列（14）：作用域链(Scope Chain)](http://www.cnblogs.com/tomxu/archive/2012/01/18/2312463.html)
- [javascript 执行环境，变量对象，作用域链](http://segmentfault.com/a/1190000000533094)
- [认识javascript中的作用域和上下文](http://yanhaijing.com/javascript/2013/08/30/understanding-scope-and-context-in-javascript/)
- [Javascript作用域原理](http://www.laruence.com/2009/05/28/863.html)
- [JavaScript执行环境 + 变量对象 + 作用域链 + 闭包](http://www.cnblogs.com/no-particular/archive/2013/01/31/2887293.html)



# callback问题

js编程遇到的最大问题就是单线程异步问题，这里面涉及最多的肯定就是callback了，不能处理好callback问题，常常会出现大量的嵌套情况，就是著名的`callback hell`了。

ES6中会引入一个新的规范，叫做Promise。这可以规范我们使用异步的情况。

## releasing Zalgo

What it means is a function that accepts a callback and sometimes returns it right away, and some other times it returns it after some delay, in the future.

就是我们的代码之中的callback,可能sync，也可能async触发，比如：

```
function register(options, callback) {
    var first_name = (options['first_name'] || '').trim();
    var last_name = (options['last_name'] || '').trim();
    var errors = [];

    if (!first_name) {
        errors.push(['first_name', 'Please enter a valid name']);
    }
    if (!last_name) {
        errors.push(['last_name', 'Please enter a valid name']);
    }
    if (errors.length) {
        return callback(null, errors);
    }

    var params = {
        'user': {
            'email': options['email'],
            'first_name': first_name,
            'last_name': last_name,
            'new_password': options['new_password'],
            'new_password_confirmation': options['new_password_confirmation'],
            'terms': '1'
        },
        'vrid': options['vrid'],
        'merge_history': options['merge_history'] || 'true'
    };

    requestWithSignature('post', '/api/v2/users', params, callback);
}
```

而最好的做法，是保证callback全是sync或者async， 那么将上面的修改为:

```
if (errors.length) {
  process.nextTick(function() {
    callback(null, errors);
  });
  return;
}
```

就可以避免`releasing Zalgo`。

## 参考资料

- [Callback 在大型编程时的一般性问题](https://github.com/hax/hax.github.com/issues/11)
- [Designing APIs for Asynchrony](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
- [Don't release Zalgo!](https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md)